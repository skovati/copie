package gov.nasa.jpl.aerie.json;

import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonValue;
import java.util.Objects;
import java.util.function.Function;

/**
 * An interface for two-way conversion between JSON documents and domain objects.
 *
 * <p> This interface is designed for the composition of complex JSON parsers by building them up from simpler ones.
 * For instance, a parser for a primitive data type like an integer might be used as an element
 * of a parser for an object with one or more integer fields. </p>
 *
 * <p> This interface helps avoid the situation in which a parser is modified without making analogous changes
 * to the corresponding unparser (printer), since both capabilities are implemented by the same object.
 * Moreover, since the parser is defined separately from the domain type it represents,
 * parsers can be defined for types not owned by the developer of the parser,
 * or for types that may be serialized to multiple other formats depending on the context. </p>
 *
 * <p> We encourage a style of composition emphasizing the overall structure of the supported JSON documents,
 * which is consolidated into a single co-located <a href="https://en.wikipedia.org/wiki/Formal_grammar">grammar</a>.
 * A developer should not build a parser by implementing this interface, but rather by building a parser up from
 * pre-existing parsers and combinators. New parsers for leaf-level data types may be defined, of course, but they
 * should be the exception, not the rule. </p>
 *
 * @param <T>
 *   the type of domain object convertible with JSON
 * @see BasicParsers
 */
public interface JsonParser<T> {
  /**
   * Produces a JSON Schema document fragment describing the format of JSON documents accepted by
   * {@link #parse(JsonValue)} and produced by {@link #unparse(T)}.
   *
   * <p> The {@code anchors} parameter is an accumulator for visited sub-parsers, tracking a JSON Schema identifier
   * for each. An implementations may add to the set of anchors, but may not alter or remove an existing anchor,
   * and must not add itself. This allows an arbitrary caller to make the choice of whether to inline a definition
   * at all use-sites or reference a single copy. </p>
   *
   * <p> This method is primarily meant for use from other parsers.
   * To generate a top-level schema for a root-level parser, use {@link #getSchema()}. </p>
   *
   * @param anchors
   *   a mutable collection of JSON Schema identifiers for previously-visited parsers
   * @return
   *   a JSON Schema document describing the format of JSON documents supported by this parser.
   */
  JsonObject getSchema(SchemaCache anchors);

  /**
   * Attempts to parse a JSON document into the domain type {@code T}.
   *
   * <p> This method must successfully parse any document generated by {@link #unparse(T)},
   * and the resulting domain value must be equal to the one that produced that document.
   * No guarantees are made for documents not generated by the {@code unparse} method.
   * See {@link #getSchema()} for more on the relationships among these methods. </p>
   *
   * @param json
   *   the JSON document to parse into a domain value
   * @return
   *   a wrapped domain value if parsing succeeds, or failure information otherwise
   */
  JsonParseResult<T> parse(JsonValue json);

  /**
   * Produces a JSON document representing the given value.
   *
   * <p> The document produced by this method must validate against the schema returned by {@link #getSchema()},
   * and must be parsed successfully by {@link #parse(JsonValue)} into a value equal to the one given here. </p>
   *
   * @param value
   *   a domain value to encode in JSON
   * @return
   *   a JSON document representing the given value
   */
  JsonValue unparse(T value);

  /**
   * Produces a JSON Schema document describing the format of JSON documents produced by {@link #unparse(T)}.
   *
   * <p> All documents returned from {@link #unparse(T)} must validate against this schema.
   * However, {@link #parse(JsonValue)} is only required to faithfully parse documents generated by {@link #unparse(T)}.
   * The {@code parse} method may reject other documents that validate relative to the schema (for instance, if the
   * document does not maintain invariants required of the domain type), and may accept other documents that do not
   * validate. </p>
   *
   * <p> Individual parsers may make stronger guarantees about the behavior of the {@code parse} method.
   * Absent such guarantees, clients of the {@code parse} method should treat this schema as advisory only:
   * if a document does not validate, then it definitely isn't something that {@code unparse} would produce. </p>
   *
   * @return
   *   a JSON Schema document describing the format of JSON documents supported by this parser.
   */
  default JsonObject getSchema() {
    return Json
        .createObjectBuilder()
        .add("$schema", Json.createValue("https://json-schema.org/draft/2020-12/schema"))
        .addAll(Json.createObjectBuilder(this.getSchema(new SchemaCache())))
        .build();
  }

  /**
   * Adapts this parser losslessly from one domain type to another with a two-way conversion.
   *
   * <p> The data types most convenient for building parsers are not always the ones we actually want to end up with
   * in the business domain. This method turns a parser that works with one (parsing-relevant) type
   * into a parser that works with another (domain-relevant) type (typically the domain-relevant one).</p>
   *
   * <p> To do this, we need to know the precise relationship between the two types. Specifically, we need a way to
   * turn any value of one into a value of the other, and vice versa. This is captured by the {@link Convert} parameter,
   * which provides a pair of forward and backward transformations. </p>
   *
   * @param <S>
   *   the new domain type to convert to
   * @param transform
   *   the reversible transformation faithfully mapping between {@code T} objects and {@code S} objects
   * @return
   *   a parser supporting the same JSON documents as this parser, but for domain type {@code S}.
   */
  default <S> JsonParser<S> map(final Convert<T, S> transform) {
    Objects.requireNonNull(transform);

    final var self = this;

    return new JsonParser<>() {
      @Override
      public JsonObject getSchema(final SchemaCache anchors) {
        return self.getSchema(anchors);
      }

      @Override
      public JsonParseResult<S> parse(final JsonValue json) {
        return self.parse(json).mapSuccess(transform::from);
      }

      @Override
      public JsonValue unparse(final S value) {
        return self.unparse(transform.to(value));
      }
    };
  }

  /**
   * Adapts this parser losslessly from one domain type to another.
   *
   * <p> The data types most convenient for building parsers are not always the ones we actually want to end up with
   * in the business domain. This method turns a parser that works with one (parsing-relevant) type
   * into a parser that works with another (domain-relevant) type (typically the domain-relevant one).</p>
   *
   * <p> To do this, we need to know the precise relationship between the two types. Specifically, we need a way to
   * turn any value of one into a value of the other, and vice versa. </p>
   *
   * @param <S>
   *   the new domain type to convert to
   * @param from
   *   an infallible transformation from the source type to the target type
   * @param to
   *   an infallible transformation to the source type from the target type
   * @return
   *   a parser supporting the same JSON documents as this parser, but for domain type {@code S}.
   */
  default <S> JsonParser<S> map(final Function<T, S> from, final Function<S, T> to) {
    return this.map(Convert.between(from, to));
  }
}
